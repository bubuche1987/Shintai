<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ideas</title>
</head>
<body>

<h1>Ideas</h1>

<h2>Error Handling Mechanism</h2>

<p>
This idea introduces a simple but powerful error handling mechanism for the language.
The design philosophy is that errors represent <strong>unexpected conditions</strong>, not ordinary planned failure modes.
Normal “bad outcomes” are still handled via returned values, typically with <code>MATCH</code> expressions on sum types.
</p>

<h3>Concept Overview</h3>
<ul>
  <li>Errors are exceptional.</li>
  <li>"Implicit errors" are, for example, division by zero, vector out-of-bounds, invalid magic number or exceeding the instruction count per frame. Their type is <code>(error:(), code:u16)</code>.</li>
  <li>Functions are the only entities that can catch errors. There are no <code>try...catch</code> blocks inside the code.</li>
  <li>Each function may optionally declare a <code>CATCHES</code> block, which defines how it reacts to specific error types.</li>
  <li>The catching function typically should wrap the error into a sum type (e.g., <code>Success: value | Error: error_code</code>) and return the wrapped error.</li>
  <li>If a function catches an error but doesn't <code>return</code> in the corresponding indtruction, the error will propagate. It's the very act of returning that stops the propagation of the error.</li>
</ul>

<h3>Language Syntax</h3>
<p>Functions that handle errors use <code>CATCHES</code>:</p>
<pre>
FUNCTION_BODIES
  name1: instruction1
, ...
, name2: instruction2 CATCHES
    x: type1: instruction3
  , y: type2: instruction4
  , _: instruction_default
  END
END
</pre>

<p>
The <code>CATCHES</code> block is like a series of <code>if...elseif</code> conditions for error types, with <code>_</code> as a catch-all.
If no matching handler is found, or if the handler doesn't return, the error propagates up to the caller.
</p>

<h3>Compiler Responsibilities</h3>
<ul>
  <li>The compiler collects all error types that can be thrown or caught.</li>
  <li>It creates a global table:
    <ul>
      <li>Implicit <code>typeid</code> column</li>
      <li><code>length_in_bytes</code> column</li>
    </ul>
  </li>
  <li>Functions capable of catching errors are stored first in their module; the module records the number of such functions.</li>
  <li>The catching code is stored right after the function.</li>
</ul>

<h3>Runtime Implementation</h3>

<p>To raise an error:</p>
<ol>
  <li>Push the error payload (data visible to the program) on the stack.</li>
  <li>Push the <code>typeid</code> of the error.</li>
  <li>Call a special <code>syscall</code> for error throwing.</li>
</ol>

<p>The syscall then:</p>
<ol>
  <li>Unwinds the stack, function by function.</li>
  <li>For each function:
    <ul>
      <li>Checks if the function has a <code>CATCHES</code> block.</li>
      <li>If yes, jumps to the catching sequence (series of type checks and associated instructions).</li>
      <li>If no handler matches, continues unwinding and rethrows the error.</li>
    </ul>
  </li>
</ol>

<p>This mechanism is invisible at the language level: the developer only writes <code>CATCHES</code> blocks, while the runtime performs stack unwinding and handler matching.</p>

<h2>Generics and <code>?</code></h2>

<p>The idea is twofold. The first part is to introduce generic types:</p>
<pre>
TYPEDEFS
  vector_of_five&lt;T&gt;: T^5
END
</pre>

<p>Then, the meta-types <code>Result</code> and <code>Option</code> would be defined:</p>
<pre>
TYPEDEFS
  Result&lt;T,E&gt;: (
    Success:T,
  | Error:E
  )
, Option&lt;T&gt;: (
    Some:T,
  | None:()
  )
END
</pre>

<p>
  Once this is done, we can introduce the operator <code>?</code>.
  The idea is that this operator either unwraps the value or returns what is given to it.
</p>

<pre>
SET
  foo: bar?
END
</pre>

<p>It would be a shorthand for:</p>

<pre>
MATCH bar WITH
  Success:x: SET foo: x END
, Error:_: return bar
END
</pre>

<p>Or:</p>

<pre>
MATCH bar WITH
  Some:x: SET foo: x END
, None:_: return bar
END
</pre>

<p>However, the operator<code>?</code> is problematic: in the absence of a <code>defer</code> statement, it's an invitation to oeak resources, as it does a return without giving the possibility to cleanup resources.</p>
  
</body>
</html>
