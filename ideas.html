<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ideas</title>
</head>
<body>

<h1>Ideas</h1>

<h2>Error Handling Mechanism</h2>

<p>
This idea introduces a simple but powerful error handling mechanism for the language.
The design philosophy is that errors represent <strong>unexpected conditions</strong>, not ordinary planned failure modes.
Normal “bad outcomes” are still handled via returned values, typically with <code>MATCH</code> expressions on sum types.
</p>

<h3>Concept Overview</h3>
<ul>
  <li>Errors are exceptional.</li>
  <li>"Implicit errors" are, for example, division by zero, vector out-of-bounds, invalid magic number or exceeding the instruction count per frame. Their type is <code>(error:(), code:u16)</code>.</li>
  <li>Functions are the only entities that can catch errors. There are no <code>try...catch</code> blocks inside the code.</li>
  <li>Each function may optionally declare a <code>CATCHES</code> block, which defines how it reacts to specific error types.</li>
  <li>The catching function typically should wrap the error into a sum type (e.g., <code>Success: value | Error: error_code</code>) and return the wrapped error.</li>
  <li>If a function catches an error but doesn't <code>return</code> in the corresponding indtruction, the error will propagate. It's the very act of returning that stops the propagation of the error.</li>
</ul>

<h3>Language Syntax</h3>
<p>Functions that handle errors use <code>CATCHES</code>:</p>
<pre>
FUNCTION_BODIES
  name1: instruction1
, ...
, name2: instruction2 CATCHES
    x: type1: instruction3
  , y: type2: instruction4
  , _: instruction_default
  END
END
</pre>

<p>
The <code>CATCHES</code> block is like a series of <code>if...elseif</code> conditions for error types, with <code>_</code> as a catch-all.
If no matching handler is found, or if the handler doesn't return, the error propagates up to the caller.
</p>

<h3>Compiler Responsibilities</h3>
<ul>
  <li>The compiler collects all error types that can be thrown or caught.</li>
  <li>It creates a global table:
    <ul>
      <li>Implicit <code>typeid</code> column</li>
      <li><code>length_in_bytes</code> column</li>
    </ul>
  </li>
  <li>Functions capable of catching errors are stored first in their module; the module records the number of such functions.</li>
  <li>The catching code is stored right after the function.</li>
</ul>

<h3>Runtime Implementation</h3>

<p>To raise an error:</p>
<ol>
  <li>Push the error payload (data visible to the program) on the stack.</li>
  <li>Push the <code>typeid</code> of the error.</li>
  <li>Call a special <code>syscall</code> for error throwing.</li>
</ol>

<p>The syscall then:</p>
<ol>
  <li>Unwinds the stack, function by function.</li>
  <li>For each function:
    <ul>
      <li>Checks if the function has a <code>CATCHES</code> block.</li>
      <li>If yes, jumps to the catching sequence (series of type checks and associated instructions).</li>
      <li>If no handler matches, continues unwinding and rethrows the error.</li>
    </ul>
  </li>
</ol>

<p>This mechanism is invisible at the language level: the developer only writes <code>CATCHES</code> blocks, while the runtime performs stack unwinding and handler matching.</p>

<h2>Generics and <code>?</code></h2>

<p>The idea is twofold. The first part is to introduce generic types:</p>
<pre>
TYPEDEFS
  vector_of_five&lt;T&gt;: T^5
END
</pre>

<p>Then, the meta-types <code>Result</code> and <code>Option</code> would be defined:</p>
<pre>
TYPEDEFS
  Result&lt;T,E&gt;: (
    Success:T,
  | Error:E
  )
, Option&lt;T&gt;: (
    Some:T,
  | None:()
  )
END
</pre>

<p>
  Once this is done, we can introduce the operator <code>?</code>.
  The idea is that this operator either unwraps the value or returns what is given to it.
</p>

<pre>
SET
  foo: bar?
END
</pre>

<p>It would be a shorthand for:</p>

<pre>
MATCH bar WITH
  Success:x: SET foo: x END
, Error:_: return bar
END
</pre>

<p>Or:</p>

<pre>
MATCH bar WITH
  Some:x: SET foo: x END
, None:_: return bar
END
</pre>

<h2>Destructors</h2>

<p>
  The problem with the two previous ideas is that they exit the function without cleaning up the resources used.
  <strong>There are currently no resources</strong> in the PL, so it's not a real problem, but they'll eventually arrive.
  The idea presented here is to simply introduce destructors for those resources.
  But it's not that simple.
</p>

<p>
  Unlike in C++, this PL has implicit errors. 
  In C++, divisions by zero are Undefined Behavior. In this PL they raise an error.
  There could even be an exception raised at any instruction if it exceeds the instructions count.
</p>

<p>
  Similarly, the operator <code>?</code> introduces early returns everywhere it is used.
</p>

<p>
  To solve that, the idea is to introduce additional layers in the frames stack. Instead of having just one frame by function call, there could be an additional frame per resource.
  Declaring a resource would create a "resource block" containing the rest of the instruction block. 
  This "resource block" would be our additional frame.
</p>

<pre>
BEGIN
  instruction1;
  instruction2;
  ...
  RESOURCES
    r: Resource&lt;File&gt;
  END
  instruction3;
  ...
  instruction4;
END
</pre>

<p>would become, at compile time, something like:</p>

<pre>
BEGIN
  instruction1;
  instruction2;
  ...
  RESOURCES
    r: Resource&lt;File&gt;
  BEGIN
    instruction3;
    ...
    instruction4;
  END
  # call to the destructor of r
END
</pre>

<p>
  This additional frame on the stack would let the exception handling mechanism call the destructor for the resource.
  Resources should be rare in the program anyway. Not all the types will have a destructor attached to them.
  Also, if several resources are declared in the same <code>RESOURCES</code>, only one "resource block" is needed.
</p>

<p>
  The destructors part should be followed by an <code>if</code> to determine where the execution should continue.
  This is because the same block of code will be executed whether we exit the "resource block" naturally (reaching the end of the instructions block before it), because we <code>break</code>, <code>continue</code>, encounter an error, or <code>return</code>, explicitly or via the operator <code>?</code>.
  One byte should be allocated per thread to contain that information, and be filled when a jump instruction is encountered.
  However, as there is no such thing as "per thread" in that language, it should be allocated in each function containing one or more "resource blocks".
  It will be added by the compiler.
</p>

</body>
</html>
